"""KAT file interface

Python interface to Known Answer Test files generated by the reference Ascon implementations from https://github.com/ascon/ascon-c.
KAT vectors are assumed to be stored in a text file and separated by a blank line. An example vector is given below:

    Count = 1
    Key = 000102030405060708090A0B0C0D0E0F
    Nonce = 000102030405060708090A0B0C0D0E0F
    PT = 
    AD = 
    CT = E355159F292911F794CB1432A0103A8A

Examples:
    Retrieve a single vector:

        import ascon_kat_vectors

        vec = ascon_kat_vectors.get(23)
        print(vec)

    Iterate over a random subset of vectors:

        import ascon_kat_vectors

        for vec in ascon_kat_vectors.select(ad_size=1, k=10):
            print(vec)

    Iterate over the whole database of vectors:

        import ascon_kat_vectors

        for vec in ascon_kat_vectors.select():
            print(vec)
"""

import enum
import pathlib
import random

from typing import List, Dict, Tuple, Iterator, Optional


class Variant(enum.Enum):
    Ascon128 = "Ascon-128"


class Vector:

    def __init__(
        self,
        count: int,
        key: bytes,
        nonce: bytes,
        ad: bytes,
        pt: bytes,
        ct: bytes,
        tag: bytes,
        variant: Variant
    ):
        self.count = count
        self.key = key
        self.nonce = nonce
        self.ad = ad
        self.pt = pt
        self.ct = ct
        self.tag = tag
        self.variant = variant

    def __repr__(self) -> str:
        args = [
            ("count", self.count),
            ("key", f"'{self.key.hex()}'"),
            ("nonce", f"'{self.nonce.hex()}'"),
            (f"ad", f"'{self.ad.hex()}' ({self.ad_size} B)"),
            (f"pt", f"'{self.pt.hex()}' ({self.pt_size} B)"),
            ("ct", f"'{self.ct.hex()}'"),
            ("tag", f"'{self.tag.hex()}'"),
            ("variant", f"'{self.variant.value}'"),
        ]
        args = ", ".join(f"{attr}={value}" for attr, value in args)
        return f"{self.__class__.__name__}({args})"

    @property
    def ad_w_padding(self):
        return pad(self.ad, allow_empty=True)

    @property
    def pt_w_padding(self):
        return pad(self.pt, allow_empty=False)

    @property
    def ad_size(self):
        return len(self.ad)
    
    @property
    def pt_size(self):
        return len(self.pt)


def pad(data: bytes, block_size=8, allow_empty=True) -> bytes:
    """Pad Ascon input data.

    Ascon specifications permits empty associated data but requires at least one block of plaintext.
    In order to mimick this conditional behavior, an empty bytes object is returned when
      an empty bytes object is provided and argument "allow_empty" is True.
    """
    if (not data) and allow_empty:
        return data
    n = block_size - (len(data) % block_size) - 1
    return data + b"\x80" + (b"\x00") * n


def vector_from_dict(vec: dict) -> Vector:
    """Create a Vector object from a text representation.

    The original size of input data is stored before data is padded.
    The ciphertext and the tag are extracted from the concatenated "CT" field based on the plaintext size.
    """
    count = int(vec["Count"])
    key = bytes.fromhex(vec["Key"])
    nonce = bytes.fromhex(vec["Nonce"])
    ad = bytes.fromhex(vec["AD"])
    pt = bytes.fromhex(vec["PT"])
    ct = bytes.fromhex(vec["CT"])
    pt_size = len(pt)
    ct, tag = ct[:pt_size], ct[pt_size:]
    variant = vec["variant"]
    return Vector(
        count=count,
        key=key,
        nonce=nonce,
        ad=ad,
        pt=pt,
        ct=ct,
        tag=tag,
        variant=variant
    )


_vectors: List[Vector] = []
_by_count: Dict[Tuple[int, Variant], Vector] = {}


def _update_from_dict(d):
    """Parse a KAT vector text description into a Vector object and store it internally."""
    v = vector_from_dict(d)
    _vectors.append(v)
    # each vector is uniquely identified by its 'Count' attribute inside a KAT variant
    _by_count[(v.count, v.variant)] = v


def read_kat(path, variant: Variant = Variant.Ascon128):
    """Parse a KAT file generated by the Ascon ref. implementation."""
    if not isinstance(variant, Variant):
        raise TypeError(f"argument 'variant' must be of type Variant.")
    vec = {}
    variant = {"variant": variant}
    with open(str(path), "r") as f:
        for line in f:
            if not line.strip() and vec:
                vec.update(variant)
                _update_from_dict(vec)
                vec = {}
            else:
                key, value = line.split("=", 1)
                vec[key.strip()] = value.strip()
        if vec:
            vec.update(variant)
            _update_from_dict(vec)


def select(
    ad_size: Optional[int] = None,
    pt_size: Optional[int] = None,
    k: Optional[int] = None,
    variant: Variant = Variant.Ascon128,
) -> Iterator[Vector]:
    """Return an iterator over a selection of KAT vectors.

    If argument "ad_size" or "pt_size" are provided, vectors are selected from a subset based on these attributes.
    If argument "k" is provided, vectors are selected from a random k-sample of the selected subset.
    Otherwise, an iterator over the whole subset is returned.
    """
    if not isinstance(variant, Variant):
        raise TypeError(f"argument 'variant' must be of type Variant.")
    subset = filter(lambda v: v.variant == variant, _vectors)
    if ad_size is not None:
        if ad_size < 0:
            raise ValueError(
                f"the ad size must be greater or equal to 0, got: {ad_size}"
            )
        subset = (v for v in subset if v.ad_size == ad_size)
    if pt_size is not None:
        if pt_size < 0:
            raise ValueError(
                f"the pt size must be greater or equal to 0, got: {pt_size}"
            )
        subset = (v for v in subset if v.pt_size == pt_size)
    if k is not None:
        if k < 1:
            raise ValueError(f"the sample size must be greater or equal to 1, got: {k}")
        indices = [v.count for v in subset]
        indices = random.sample(indices, min(k, len(indices)))
        subset = (get(i, variant) for i in indices)
    return subset


def get(count: int, variant: Variant = Variant.Ascon128) -> Vector:
    """Retrieve a KAT vector from its count id."""
    if not isinstance(variant, Variant):
        raise TypeError(f"argument 'variant' must be of type Variant.")
    try:
        return _by_count[(count, variant)]
    except KeyError:
        raise ValueError(f"vector {count} not found for variant '{variant.value}'.")


def get_size(variant: Variant = Variant.Ascon128) -> int:
    if not isinstance(variant, Variant):
        raise TypeError(f"argument 'variant' must be of type Variant.")
    return sum(1 for _ in filter(lambda v: v.variant == variant, _vectors))
